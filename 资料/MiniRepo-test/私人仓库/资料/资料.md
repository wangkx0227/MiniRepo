总结：https://docs.python.org/zh-cn/3.13

# 生成器函数

```python
是什么：
	一个使用yield语句的函数或者类的方法被成为生成器函数。
    它使用 yield 语句来生成值，而不是使用 return 语句返回值。
    生成器函数在调用时不会立即执行，而是返回一个生成器对象，该对象可以在需要时逐个生成值。生成器函数是实现迭代器的一种非常简洁和高效的方式。

说明:
	在被调用时，需要通过 next() 方法将导致这个函数一直运行到它使用 yield 语句提供一个值。
	当函数执行到return或者yield的函数体末尾，就会抛出 StopIteration 异常并且该迭代器将到达所返回的值集合的末尾。

实例：
def my_generator():
    yield 1
    yield 2
    yield 3


gen = my_generator() # 这个就是一个生成器对象，当生成器被声明时，不会立即执行（这就是它的惰性求值）
print(next(gen))  # 打印 1
print(next(gen))  # 打印 2
print(next(gen))  # 打印 3
print(next(gen))  # 抛出异常 StopIteration

for i in gen: # 可以使用for循环调用，调用的情况下，就算值读取完毕不会出现 StopIteration
    print(i)


# 说明：
    1.只要函数中包含yield关键字，就是生成器函数，那么就需要使用next调用或者for或者其他的迭代方式调用，每一次调用获取一个值。
    2.当值被获取完毕后，就会抛出 StopIteration 异常，当使用for循环调用会自动处理  StopIteration，for 循环是最常见的获取生成器值的方式。

# 优势：
    惰性求值：生成器函数在需要时才生成值，而不是一次性生成所有值，节省内存。
    高效：生成器函数可以处理无限序列，因为它们不需要一次性加载所有数据。
    简洁：生成器函数的使用方式非常简洁，通过 for 循环即可遍历。

# 使用场景：
    1.生成器函数非常适合处理大数据和无限序列。
    2.逐行读取文件内容（处理大数据，无需一次性将数据加载内存中，而是逐个生成，节省内存）。
        def read_file(file_path):
            with open(file_path, 'r') as file:
                for line in file:
                    yield line.strip()
        
        # 使用生成器函数
        for line in read_file('example.txt'):
            print(line)
    
    2.逐条处理查询结果。
        import sqlite3
        def query_database(query):
            conn = sqlite3.connect('../example.db')
            cursor = conn.cursor()
            cursor.execute(query)
            for row in cursor:
                yield row
        
        # 使用生成器函数
        for row in query_database('SELECT * FROM my_table'):
            print(row)

    3.逐个处理响应数据。
        import requests
    
        def fetch_data(url):
            response = requests.get(url, stream=True)
            for line in response.iter_lines():
                yield line.decode('utf-8')
        
        # 使用生成器函数
        for line in fetch_data('https://api.example.com/data'):
            print(line)
# 补充其他方法：
    1.生成器函数不仅可以生成值，还可以通过 send() 方法接收值。这使得生成器函数可以实现更复杂的双向通信。
    def echo():
        while True:
            received = yield
            print(received)
    
    gen = echo()
    next(gen)  # 启动生成器
    gen.send("Hello, World!")  # 输出：Hello, World!
    gen.send("Python is awesome!")  # 输出：Python is awesome!
    
    2.生成器函数可以通过 close() 方法提前终止。这在某些情况下非常有用，例如在处理无限序列时需要提前退出
    def my_generator():
        yield 1
        yield 2
        yield 3
    
    gen = my_generator()
    print(next(gen))  # 输出：1
    gen.close()
    try:
        print(next(gen))  # 抛出 StopIteration 异常
    except StopIteration:
        print("Generator closed")


# 总结：
    迭代器函数最大的有点就是节省内存，尤其是处理大量数据时，不会将数据一次性的读取到内存中，而是一条条读取，因为每次请求只会给一个值（上一次暂停的位置继续执行，并返回下一个值）。
    最终使用内存量还是与不使用yiled的相同。
```

# 协程函数
```python
需要使用 async 和 await 关键字，可以实现高效的异步代码，特别适合i/o密集性的任务。
async作用：
    async 关键字用于定义异步函数。
    async def  # 声明异步函数，函数在被调用时会返回一个 coroutine 对象。

await作用：
    await 关键字，停止当前异步函数执行，等待被调用的异步函数完成。
    await 关键字，不仅仅作用是暂停，同时为了获取被调用异步函数的返回值结果。
    await 关键字将异步操作交给事件循环管理，确保任务在适当的时间被唤醒和执行。
    如果不适用 await，事件无法正常调度和管理异步任务。
    await add() # 调用异步函数

异步函数：
    它可能包含 await 表达式以及 async with 和 async for 语句，只能在异步函数中使用
# 示例：
    import asyncio # 需要通过 asyncio 模块 启动事件循环，这个模块主要作用 负责调度和执行异步任务。
    async def platform():
        return 12
    
    async def main(num):
        print(num)
        value = await platform()
        print(f"函数返回值如下：{value}")
    
    asyncio.run(main(10)) # 通过run进行调用异步函数

# 注意：
    不是异步函数，无法使用 await 关键字，会出现异常。
    在异步函数中调用另一个异步函数，必须使用 await 关键字，这是因为 await 关键字用于暂停当前异步函数的执行，等待被调用的异步函数完成。如果不适用await调用就会出现错误异常。

# 场景
    非常适合处理 I/O 密集型任务，尤其是那些涉及网络请求、文件读写等操作的场景。异步编程可以显著提高程序的性能和响应能力，因为它允许程序在等待 I/O 操作完成时执行其他任务，而不是阻塞当前线程。
    1.网络请求：aiohttp，可以实现同时发起多个网络请求，不会阻塞主线程，程序可以继续执行其他任务。
        import asyncio
        import aiohttp
        
        async def fetch(url):
            async with aiohttp.ClientSession() as session:
                async with session.get(url) as response:
                    return await response.text()
        
        async def main():
            urls = [
                "https://api.example.com/data1",
                "https://api.example.com/data2",
                "https://api.example.com/data3"
            ]
            tasks = [fetch(url) for url in urls]
            results = await asyncio.gather(*tasks)
            for result in results:
                print(result)
        
        # 运行主函数
        asyncio.run(main())
    2.异步读写文件：aiofiles，多大型文件的读写，提高读写效率
        import asyncio
        import aiofiles
        
        async def read_file(file_path):
            async with aiofiles.open(file_path, 'r') as file:
                return await file.read()
        
        async def write_file(file_path, content):
            async with aiofiles.open(file_path, 'w') as file:
                await file.write(content)
        
        async def main():
            content = await read_file('input.txt')
            await write_file('output.txt', content.upper())
        
        # 运行主函数
        asyncio.run(main())
    3.数据库操作：aiomysql，可以同时执行多个数据库查询任务，提高效率。
        import asyncio
        import aiomysql
        
        async def query_database():
            conn = await aiomysql.connect(host='127.0.0.1', port=3306, user='root', password='password', db='test')
            async with conn.cursor() as cur:
                await cur.execute("SELECT * FROM my_table")
                result = await cur.fetchall()
                print(result)
            conn.close()
        
        # 运行主函数
        asyncio.run(query_database())
    4.异步并发任务，同时执行多个任务。
        import asyncio
        
        async def task1():
            print("Task 1 started")
            await asyncio.sleep(2)
            print("Task 1 completed")
            return "Result 1"
        
        async def task2():
            print("Task 2 started")
            await asyncio.sleep(1)
            print("Task 2 completed")
            return "Result 2"
        
        async def main():
            result1, result2 = await asyncio.gather(task1(), task2())
            print(f"Task 1 result: {result1}")
            print(f"Task 2 result: {result2}")
        
        # 运行主函数
        asyncio.run(main())
# asyncio 函数方法
    asyncio.run(main()) # 启动事件循环并运行主协程 main，直到完成。
    mainval,mainval2 = asyncio.gather(main(),main1()) # 执行多个携程，并且返回结果
    asyncio.wait_for(main(), timeout=5) # 等待main执行完毕，最多等待时间5秒
    asyncio.sleep(1) # 暂停当前协程执行 1 秒

    tast1 = asyncio.create_task(main()) # 转换为任务（Task），并将其添加到事件循环中。val是一个Task的对象，可以实现并发执行
    tast2 = asyncio.create_task(main2()) # 转换为任务（Task），并将其添加到事件循环中。val是一个Task的对象，可以实现并发执行
    tast1.cancel() # 在执行前，取消任务
    tast2.cancel() # 在执行前，取消任务
    await tast1  # 等待 tast1 完成
    await tast2  # 等待 tast2 完成
    print(tast1.result()) # 获取执行完毕的结果，需要在 await 调用完毕后执行
    print(tast2.result()) # 获取执行完毕的结果，需要在 await 调用完毕后执行

    import asyncio
    # 获取已有的调用
    loop = asyncio.get_event_loop() # 需要在循环事项完毕前可以获取使用，获取当前线程的事件循环。如果在循环事项后调用就会出现异常报错
    loop.run_until_complete(main()) # 调用
    loop.close() # 关闭
    # 创建新的调用
    loop = asyncio.new_event_loop() # 创建一个新的 事件循环
    asyncio.set_event_loop(loop) # 设置
    loop.run_until_complete(main())
    loop.close()
 	# asyncio.open_connection 打开一个异步的TCP连接
    async def tcp_echo_client():
        reader, writer = await asyncio.open_connection('127.0.0.1', 8888)
        writer.write(b'Hello')
        await writer.drain()
        data = await reader.read(100)
        print(data.decode())
        writer.close()
        await writer.wait_closed()

    asyncio.run(tcp_echo_client())
    # asyncio.start_server 启动一个异步TCP服务器
    async def handle_client(reader, writer):
        data = await reader.read(100)
        writer.write(data)
        await writer.drain()
        writer.close()

    async def main():
        server = await asyncio.start_server(handle_client, '127.0.0.1', 8888)
        async with server:
            await server.serve_forever()

    asyncio.run(main())
    #  asyncio.Semaphore 创建一个异步信号量 用于限制同时运行的协程数量。
    semaphore = asyncio.Semaphore(2)
    
    
    async def task():
        async with semaphore:
            print("Task acquired semaphore")
            await asyncio.sleep(1)
            print("Task released semaphore")
    
    
    async def main():
        await asyncio.gather(task(), task(), task())
    
    
    asyncio.run(main())
    # asyncio.Lock 创建一个异步锁，用户同步协程执行
    lock = asyncio.Lock()
    
    async def task():
        async with lock:
            print("Task acquired lock")
            await asyncio.sleep(1)
            print("Task released lock")
    
    async def main():
        await asyncio.gather(task(), task())
    
    asyncio.run(main())
	# asyncio.to_thread 在另外一个线程中运行一个同步函数
    def blocking_io(): # 同步函数
        print("Start blocking_io")
        time.sleep(1)
        print("End blocking_io")
        return "Result"


    async def main(): # 异步函数
        result = await asyncio.to_thread(blocking_io) # 开启一个线程，执行这个同步函数
        print(result)


    asyncio.run(main())
    
    # 关于 create_task 与 wait_for的区别
        相同点：都可以执行多个任务的并发执行
        不同点：
            wait_for：用于并发运行多个协程，并返回它们的结果。它会等待所有协程完成，并将结果收集到一个列表中（自动收集），如果其中某个协程任务出现错误就会抛出异常。
            create_task：用于将协程对象转换为任务（Task），并将其添加到事件循环中。任务是事件循环中的一个可等待对象，可以并发运行。相对与wait_for更加灵活。
                1.可以单独的管理每个任务
                2.可以对任务进行关闭或者获取状态等操作。
                3.相对于wait_for更加灵活，更细粒度的管理。
        总结：
            create_task 与 wait_for 都可以执行多个任务进行并发。
            await asyncio.gather(task1(), task2())：适合并发运行多个协程，并自动收集结果。适用于需要同时运行多个协程并获取它们的结果的场景。
            asyncio.create_task(main())：适合需要单独管理每个任务的场景，例如取消任务、检查任务状态等。提供了更多的灵活性和控制能力。
            如果你需要更细粒度的管理使用create_task，如果只是为了多格任务同步进行使用wait_for。
```
# 异步生成器函数
```python
# 解释：
	异步函数  + 生成器关键字 
	import asyncio
    async def add(): # 异步生成器函数
        for i in range(3):
            await asyncio.sleep(1)  # 模拟异步操作
            yield i
            
	async def main():
        async for value in add():
            print(value)
     asyncio.run(main())
# 特点：
	这样的函数在被调用时，将返回一个 asynchronous iterator 对象，该对象可在 async for 语句中被用来执行函数体。
	当函数执行到空的 return 语句或函数末尾时，将会引发 StopAsyncIteration 异常并且异步迭代器也将到达要产生的值集合的末尾。

# 场景：
	非常适合处理异步数据流，尤其是那些需要逐个处理数据的场景。它们允许你以异步的方式生成数据，而不需要一次性加载所有数据到内存中，从而节省内存并提高效率。
    1.异步读取文件，异步生成器函数非常适合处理异步数据流，例如从网络或文件中逐个读取数据。
    import asyncio
    import aiofiles

    async def async_read_file(file_path):
        async with aiofiles.open(file_path, 'r') as file:
            async for line in file:
                yield line.strip()

    async def main():
        async for line in async_read_file('example.txt'):
            print(line)

    asyncio.run(main())
    
    2.异步网络请求，在处理多个异步网络请求时，异步生成器函数可以并发地获取数据，提高效率。
    import asyncio
    import aiohttp

    async def fetch(url):
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                return await response.text()

    async def async_fetch_urls(urls):
        for url in urls:
            yield await fetch(url)

    async def main():
        urls = [
            "https://api.example.com/data1",
            "https://api.example.com/data2",
            "https://api.example.com/data3"
        ]
        async for result in async_fetch_urls(urls):
            print(result)

    asyncio.run(main())
    
    3.异步数据库操作，在异步数据库操作中，异步生成器函数可以用于逐条处理查询结果，避免一次性加载所有数据。
	import asyncio
    import asyncpg

    async def async_query_database(query):
        pool = await asyncpg.create_pool(
            user='postgres',
            password='password',
            database='mydb',
            host='localhost'
        )
        async with pool.acquire() as conn:
            async for row in conn.cursor(query):
                yield row
        await pool.close()

    async def main():
        query = 'SELECT * FROM users'
        async for row in async_query_database(query):
            print(row)

    asyncio.run(main())
	
    .....
    
# 通过使用异步生成器函数，你可以以异步的方式逐个处理数据，节省内存并提高程序的效率和响应能力。
```

# 类

```bash
类的
	__new__() # 重载的变体类型，只有在特殊情况下才会使用当前方法重写：如实现单例模式或自定义对象创建过程，需要调用super()来创建一个实例对象，除非写错了在他的方法中直接返回了，实例化类。
	class MyClass:
        def __new__(cls):
            print("调用 __new__")
            return MyClass()  # 自己调用自己，会无限递归

    obj = MyClass()  # 会 RecursionError

	__init__() # 形成一个新的实例，它只会在实例化的时候调用一次。
	# 在重载类对象时，会将参数传递给 __new__() 也同时传递给 __init__()初始化新的实例。
	obj = MyClass()
    ↓
    MyClass.__new__(cls) → 创建实例对象
    ↓
    MyClass.__init__(self) → 初始化这个对象
	
	
	__call__() # 它允许一个类的实例表现得像一个函数，当初始化类时，就会调用__call__()方法，执行内部的代码。
		任意类的实例可以通过在其所属类中定义 __call__() 方法变成可调用对象。


class A:

    def __new__(cls, *args, **kwargs):  # 先执行
        """
        cls：当前类。
        *args：传递给构造函数的参数。
        *kwargs：传递给构造函数的关键字参数。
        :param args:
        :param kwargs:
        """
        print("__new__ 调用")
        instance = super().__new__(cls) # 调用 object类（所有类默认继承）的 __new__方法（C语言代码） 进行生成 A 类对象实例
        return instance

    def __init__(self, value):  # 后调用
        print("__init__ 调用")


a = A(10)



__new__作用：创建类对象，创建类的新实例。它的返回值必须是一个类的实例。
    如果 __new__ 返回的是当前类的实例，那么 __init__ 方法会被调用。
    如果 __new__ 返回的是其他类型的对象，那么 __init__ 方法不会被调用。
    如果，不对__new__进行重写的情况下，python会自动创建类对象

__init__作用：实例化类对象，初始化类对象。
    __new__ 只有当前类对象才会触发__init__
    它在实例化对象时被调用，但只有在 __new__ 返回当前类的实例时才会被调用。


__new__ 与  __init__ 关系：
    __init__只有__new__有创建当前类的对象，__init__才会被调用。


为什么 __new__ 需要在方法内部使用
    instance = super().__new__(cls) # 通过super()对象调用父类的 __new__ 方法，传入当前类（cls），创建当前类对象。
    return instance # 返回当前类对象

super是什么：
    是 Python 中的一个内置函数，用于调用父类（或父类的父类）的方法。
    super() 可以帮助你正确地调用父类的方法，避免重复调用和确保方法调用的顺序正确。
    使用super()方法可以避免重复调用和顺序调用，防止重复与顺序颠倒。
    super() 会按照 MRO 调用父类的方法，确保每个方法只被调用一次，并且调用顺序正确。这在多继承的情况下尤为重要。

super行为：
	super() 会按照 MRO 调用父类的方法（也就是说mro的顺序是什么，它就会怎么调用，那么A类和B类没有直接关系，这两个类只要被C类继承【class C(A,B)】，就会间接产生关系。A类使用super().__init__()就会调用B类的__init__方法，因为mro的顺序就是这样），而不是直接调用当前类的方法。这意味着 super() 会跳过当前类，调用 MRO 中的下一个类的方法。
    所用说 MRO 的调用顺序很重要。
		
super 单继承
    class Parent:
        def __init__(self, value):
            print("Parent __init__")
            self.value = value


    class Child(Parent):
        def __init__(self, value):
            print("Child __init__")
            super().__init__(value)  # 调用当前实例的 __init__ 方法


    # 创建实例
    child = Child(10)
    """
    打印：
        Child __init__
        Parent __init__
    """

super 多继承
    class Base1:
        def __init__(self):
            print("1.Base1 __init__")
            super().__init__()  # 确保当前类的 __init__被调用


    class Base2:
        def __init__(self):
            print("2.Base2 __init__")
            super().__init__()  # 确保当前类的 __init__被调用


    class Derived(Base1, Base2):
        def __init__(self):
            print("3.Derived __init__")
            super().__init__()  # 调用父类的 __init__ 方法


    # 创建实例
    derived = Derived()
    print(Derived.mro())  # 调用：[<class '__main__.Derived'>, <class '__main__.Base1'>, <class '__main__.Base2'>, <class 'object'>]
	"""
	打印结果
        3.Derived __init__
        1.Base1 __init__
        2.Base2 __init__
	
	在 Derived init方法中使用了（super().__init__()）就触发了 mro调用关系的 Base1类的init方法，而 Base1类的init使用了（super().__init__()）触发了mro调用Base2类的init方法。所以打印结果就是这样，Base1类与Base2类压根没有直接关系，为什么Base2的init会被调用的直接原因。
	"""

    
__init__ 实例化对象到底是什么：
	实例化是将抽象的类定义转化为具体的对象的过程。
    每个实例都有自己的状态（属性值），但共享类的结构和方法。通过实例化，你可以创建多个具有相同结构但不同数据的对象，从而实现代码的复用和灵活性。
    例如：
    	class Person:
            def __init__(self, name, age):
                self.name = name
                self.age = age

            def say_hello(self):
                print(f"{self.name}-{self.age}")
                
         person1 = Person("Alice", 25) # 实例化对象1
         person2 = Person("Bob", 30) # 实例化对象2
         输入内容：
             print(person1.name)  # 输出 Alice
             print(person2.name)  # 输出 Bob
             person1.say_hello()  # 输出 Alice-25
             person2.say_hello()  # 输出 Bob-30
         
         # 从输出内容，就可以了解到，每次实例化都是一个单独的对象，但是可以同时使用类的方法变量（根据实例化传递的只不同），这意味着每个实例都可以调用类中定义的方法，而不需要为每个实例单独定义方法。
         # 总结：__init__ 进行初始化实例对象 方法共享，属性独立
         	1.独立的对象
         	2.独立的传递的数据
         	3.共享的方法
         	4.从内存角度上分析：	
                1.方法共享：类的方法存储在类的内存空间中，所有实例共享这些方法。
                2.对象独立：每个实例有独立的内存空间，存储自己的属性值。
                3.self参数：方法调用时，self参数指向具体的实例，方法内部通过self访问实例的属性。
       用现实解释：
            进行类初始化可以理解，2个人合租了一套房子，客厅，厨房，厕所是公用，也就是类的方法，而卧室是私有的也就是初始化的值。整个房间就是类的内存空间，而卧室就是在类内存空间开辟的独立内存空间存储初始化值。
```

```python
__call__():
	方法的主要作用是让对象能够被调用，即在对象后面加上括号并传递参数，就像函数调用一样。这使得对象可以模拟函数的行为。

场景：
    创建可调用对象：当你想要创建一个对象，它既能保存状态，又能像函数一样被调用时，可以使用 __call__() 方法。# 也就是类实例对象函数化调用，执行call方法。
    装饰器：在创建装饰器时，有时会用到 __call__() 方法，使得装饰器本身可以像函数一样调用。
    延迟计算：在某些情况下，你可能希望延迟计算直到对象被调用时才执行。通过实现 __call__() 方法，可以在对象被调用时执行计算。
    模拟函数行为：在某些框架或库中，可能需要对象能够像函数一样被调用，以适应特定的接口或协议。 # 将类作为一个函数一样使用。就是利用__cell__

例如-1：
    class Adder:
        def __init__(self, n):
            self.n = n

        def __call__(self, x):
            return x + self.n


    # 创建一个 Adder 实例
    adder = Adder(10)

    # 调用实例，就像调用函数一样，调用整个实例对象。
    result = adder(20)  # 输出 30
    print(result)



例如-2：
	import sqlite3
    class Database:
        def __init__(self, db_name):
            """
            初始化
            :param db_name: 存储名称
            """
            self.db_name = db_name
            self.connection = None

        def __call__(self):
            """
            对实例对象,像函数一样调用
            :return:
            """
            assert not self.connection, "数据对象不为空"
            self.connection = sqlite3.connect(self.db_name)
            return self.connection

        def close(self):
            """
            关闭数据对象
            :return:
            """
            if self.connection:
                self.connection.close()
                self.connection = None


    # 使用示例
    db = Database('example.db')

    # 调用实例获取数据库连接
    conn = db()
    # 获取数据库的光标
    cursor = conn.cursor()
    # 执行数据库操作
    cursor.execute('SELECT * FROM users')
    print(cursor.fetchall())
    # 关闭数据库连接
    db.close()



# 装饰器实现
    class CallDecorator: # 装饰器类
        def __init__(self, func):
            self.func = func # 初始化函数名称,不执行
            print("CallDecorator 初始化")

        def __call__(self, *args, **kwargs):
            print("调用")
            result = self.func(*args, **kwargs) # 执行了这个函数
            print("调用结束")
            return result


    # 使用装饰器
    @CallDecorator  # 装饰在函数上，就是将这个函数作为参数传入，并不执行.实例化了对象,当前的函数就是 test_function = CallDecorator(test_function)
    def test_function(x, y):
        print(f"输出X={x} Y={y}")
        return x + y


    # 调用函数
    result = test_function(5, 3)  # 也就是 test_function 是 CallDecorator实例化对象，调用时触发类的__call__,
    print(f"获取test_function的返回值: {result}")
    
    
    # 上面的调用操作这样写，更简单，所以说在不同的场景下需要做取舍
    a = CallDecorator(test_function)
    a(3, 5)

    
# 延迟计算的思想：第一次是空的，就直接调用计算密集型函数获取结果，结果进行赋值，第二次执行直接使用这个值，不需要在进行计算。
    class DelayedComputation:
        def __init__(self, function, *args, **kwargs):
            self.function = function
            self.args = args
            self.kwargs = kwargs
            self.result = None

        def __call__(self):
            if self.result is None:  # 是否有值,有值返回计算的结果,没有值获取计算结果并赋值
                self.result = self.function(*self.args, **self.kwargs)
            return self.result


    # 定义一个计算密集型函数
    def compute_expensive_result(x, y):
        # 模拟一个耗时的计算过程
        print("开始计算")
        import time
        time.sleep(2)
        return x * y


    # 创建一个延迟计算对象
    delayedComputation = DelayedComputation(compute_expensive_result, 3, 5)

    # 第一次调用，执行计算
    print("第一次调用，执行计算:", delayedComputation())

    # 第二次调用，直接返回缓存的结果,不在通过计算密集型函数,直接获取赋值的结果
    print("第二次调用，直接返回缓存的结果:", delayedComputation())
```

## 静态方法/类方法

| 方法            | 特点                                                         | 调用方式                                      |
| --------------- | ------------------------------------------------------------ | --------------------------------------------- |
| `@staticmethod` | 静态方法，就是类内的一个普通函数，不能使用类属性，也不能使用实例化对象属性。 | 可以使用：1.类名调用 2.可以使用实例化对象调用 |
| `@classmethod`  | 类方法，是类的一个方法，需要接受`cls`（类对象本身），通过`cls`可以访问类的属性和方法，除了不能使用实例化对象属性，其他的都可以使用。 | 可以使用：1.类名调用 2.可以使用实例化对象调用 |
| `@property`     | 是一个装饰器，用于将类的方法转换为属性，从而可以像访问属性一样访问该方法。 | 可以使用：1.可以使用实例化对象调用            |

```python
class A:
    name = "666"  # 类属性

    def __init__(self):  # 实例属性
        self.name = "name"

    @staticmethod
    def add():
        """
        将一个方法封装为静态方法，就是一个在类内部的函数。
        不能使用类属性，不能调用类的对象，不能使用类实例对象
        :return:
        """
        print("add")

    @classmethod
    def add2(cls):
        """
        把一个方法封装成类方法。类方法，除了使用实例对象的属性，其他都可以使用。
        :return:
        """
        print("add2")  # 可以使用类内的方法
        print(cls.name)  # 可以使用类属性

	@property
    def add3(self):
        """
        将方法变为一个属性进行使用，将函数变为一个变量，调用变量就可以触发函数。
        :return:
        """
        print("add3")
       


"""
静态方法：@staticmethod
    静态方法是属于类的，而不是类的实例。静态方法不需要访问类或实例的属性，因此它们不接收self或cls参数。
    
使用场景：
    1.工具函数：当一个函数与类相关，但不需要访问类或实例的属性时，可以定义为静态方法。
    2.逻辑分组：将一些逻辑相关的函数组织在一起，但这些函数不需要访问类的属性。

特点：
    1.不需要实例化类，就可以直接调用
    2.不需要接受self或者cls，这些类对象或者实例化对象参数。
    3.它就是一个在类内的普通函数，适用于不需要访问类或实例属性的工具函数或逻辑分组。

调用方式：    
    这个方法不需要进行实例化类，直接就可以使用。比如：
    1.使用类名调用：A.add()
    2.使用实例化对象调用 
        a = A() # 实例化对象
        a.add()
"""

"""
类方法：@classmethod
   类方法是属于类的，接收一个cls参数，表示类本身（也就是类对象）。类方法可以访问类的属性和方法，但不能访问实例的属性（初始化__init__的对象属性）

使用场景：
    1.用于创建类的实例，但可以根据不同的参数返回不同的实例。
    2.操作类属性，而不是实例属性。

特点：
    1.不需要实例化类，就可以直接调用，它是类本身，不是类的实例化，因此可以直接通过类名调用类方法，而不需要创建类的实例。。
    2.需要接受cls类对象本身。
    3.可以通过cls调用类内部的方法与类属性，不能调用实例化对象内的属性（实例属性需要实例化对象访问）。
    
调用方式：
    这个方法不需要进行实例化类，直接就可以使用。比如：
    1.使用类名调用：A.add2()
    2.使用实例化对象调用 
        a = A() # 实例化对象
        a.add2()
"""

"""
类方法：@property
  用于将类的方法转换为属性，从而可以像访问属性一样访问该方法。

说明：
	封装：使用 @property 可以让你对类的属性进行更细粒度的控制，像方法一样处理属性（例如：增加验证、计算等），而不需要显式调用方法。	
	属性计算：你可以让一些计算结果像属性一样被访问，避免暴露复杂的计算逻辑。
    
调用方式：
    需要使用实例化进行操作调用。比如：
    1.使用实例化对象调用 
        a = A() # 实例化对象
        a.add3

"""
```

## 注意：魔术语法，会导致调用递归的问题，比如`__getattribute__`重写，如果不使用 super() 防止递归。

## `__del__`

```python
只有在对象被销毁时，才会被调用__del__方法

在Python中，__del__方法的调用时机是由Python的垃圾回收机制决定的。__del__方法并不一定在对象被显式销毁时立即调用，而是当对象的引用计数变为0时，或者在程序退出时，Python解释器会尝试销毁对象并调用__del__方法。

class MyClass:
    def __init__(self, ):
        print("实例化")

    def __del__(self):
        print("调用")


# 创建对象
obj = MyClass() # 输出：调用。不主动使用del也会自动会触发 __del__ 这个与python的垃圾回收机制相关。

# 删除对象
# del obj  # 输出：调用


注意:
    1.__del__方法的调用时机不确定：__del__方法在对象的引用计数变为0时被调用，或者在程序退出时被调用。
    2.显式销毁对象：使用del语句可以减少对象的引用计数，但不保证__del__方法会被立即调用。
    3.循环引用问题：存在循环引用时，__del__方法可能不会被调用。
    # 所以不建议使用 __del__ 方法，因为不确定什么时候调用。
```

## `__repr__`与`__str__`

```python
__repr__ 和 __str__ 都是 Python 中用于定义对象字符串表示的特殊方法，效果都是相同的。


class MyClass:

    def __repr__(self):
        return "调用repr方法"

    def __str__(self):
        return "调用str方法"


f = MyClass()
print(repr(f))  # 调用repr方法
print(str(f))  # 调用str方法
print(f)  # 调用str方法，因为根据顺序会打印最后一个，字符串表示的特殊方法的结果。

# 注意：
    1.如果只有__str__或者__repr__其中一个对字符串特殊方法，那么使用str() 或者 repr() 打印时，只会输出存在的对字符串特殊方法。
        1.当只有 __str__ 时，str() 会调用 __str__ 方法。repr() 也会调用 __str__ 方法，因为 __str__ 是 __repr__ 的后备方法。这意味着如果没有定义 __repr__，Python 会尝试调用 __str__。
        2.当只有 __repr__ 时，str() 也会调用 __repr__ 方法，因为 __repr__ 是 __str__ 的后备方法。这意味着如果没有定义 __str__，Python 会尝试调用 __repr__。

    2.__repr__ 的输出应该尽可能详细，包含对象的所有重要属性，最好是一个合法的 Python 表达式，帮助开发者理解对象的状态。
    3.__str__ 的目标是返回一个可读性好的字符串表示，主要用于向最终用户展示对象的信息。
```

## `__bytes__`

```python
__bytes__ 是 Python 中的一个特殊方法，用于定义一个对象如何被转换为字节序列。当你对一个对象调用 bytes() 函数时，Python 会调用该对象的 __bytes__ 方法（如果定义了的话）来获取其字节表示。

class MyClass:

    def __bytes__(self):
        """
        返回的结果必须是一个转换的字节类型，返回其他的类型就会报错
        :return:
        """
        return "1111".encode("utf-8")


f = MyClass()
print(bytes(f))  # 当使用bytes调用，类对象时，就会触发类的__bytes__方法


# 场景：
	1.网络通信：
    	在网络通信中，数据通常需要以字节序列的形式发送和接收。通过定义 __bytes__ 方法，可以方便地将对象转换为字节序列，以便在网络上传输。
	2.文件存储：
    	在将对象存储到文件中时，可能需要将对象转换为字节序列。__bytes__ 方法可以定义对象的字节序列表示，方便将对象写入文件。
	3.数据序列化：
    	在数据序列化和反序列化过程中，__bytes__ 方法可以用于定义对象的字节序列表示，以便将对象序列化为字节序列，或者从字节序列反序列化为对象。
```

## `__bool__`

```bash
__bool__ 方法在 Python 中用于定义一个对象的“真值”（truthiness）。当你使用布尔上下文（如 if 语句、while 循环、bool() 函数等）对一个对象进行布尔测试时，Python 会调用该对象的 __bool__ 方法来确定其布尔值。

如果没有定义 __bool__ 方法，Python 会尝试调用 __len__ 方法（如果定义了的话）。如果 __len__ 返回 0，则对象被认为是假值（False）；否则被认为是真值（True）。如果两者都没有定义，对象默认被认为是真值。


class MyClass:
    def __init__(self, value):
        self.value = value

    def __bool__(self):
        return self.value > 0

# 示例
obj1 = MyClass(10)
obj2 = MyClass(-5)

print(bool(obj1))  # 输出: True
print(bool(obj2))  # 输出: False
```

## `__getattr__ 方法与__getattribute__与__setattr__与__delattr__`

| 特性     | `__getattribute__`                 | `__getattr__`                          |
| -------- | ---------------------------------- | -------------------------------------- |
| 何时触发 | 任何属性访问都触发                 | 仅当访问的属性不存在时触发             |
| 触发时机 | 在任何属性访问时，都会调用         | 只有当属性不存在时，才会调用           |
| 适用范围 | 通常用于拦截和修改所有属性访问行为 | 用于处理缺失的属性（例如动态属性加载） |

```bash
作用：
    __getattr__：仅在访问的属性不存在时被调用。
    __getattribute__：每次访问属性时都会被调用，无论属性是否存在。
    __setattr__：每次设置属性时都会被调用。
    __delattr__：每次删除属性时都会被调用。
    __dir__：当使用 dir() 函数时被调用，返回对象的属性列表。
    
场景：
    延迟加载：使用 __getattr__ 和 __setattr__ 实现属性的延迟加载。
    属性访问日志：使用 __getattribute__ 在每次访问属性时记录日志。
    属性验证和保护：使用 __setattr__ 和 __delattr__ 在设置和删除属性时进行验证和保护。
    动态属性列表：使用 __dir__ 动态生成对象的属性列表。


        


    
    
```

### `__getattribute__`

```bash
2.__getattribute__
	触发条件：无论属性是否存在，每次访问属性时都会调用 __getattribute__。# 只针对属性
	# 注意：
    	由于 __getattribute__ 是在访问任何属性时都会被触发，所以 如果你在 __getattribute__ 中访问对象的任何属性（包括 name、__dict__ 等），会导致无限递归。所以在__getattribute__中使用super()来调用父类的 __getattribute__，否则会导致无限递归(这样的就会根据mro的调用 方法解析顺序 调用，可以避免无线递归【默认情况下是有先找类的__getattribute__进行调用，而使用super()它根据 MRO 规则找到并调用父类的 __getattribute__】)。
    # 为什么出现递归行为直观解释
        默认行为：当你访问对象的属性时，Python 首先会 查找当前类的 __getattribute__ 方法。如果你在这个方法中访问某个属性（比如 self.some_property），这会再次触发当前类的 __getattribute__，从而导致 无限递归。

    	使用 super()：通过在 __getattribute__ 中调用 super()，你是告诉 Python：“不要在当前类中查找 __getattribute__，而是按照 MRO（方法解析顺序）到父类中去查找。” 这样，Python 就会根据 MRO 规则，逐步向上查找父类的 __getattribute__，避免了递归的问题。

    class MyClass:
        name = "小明"

        def __getattribute__(self, name):
            print(f"访问属性: {name}")  # 优先触发
            return super().__getattribute__(name)

        def __getattr__(self, item):
            return f"没有这个属性{item}"  # 如果没有这属性就会触发，它在__getattribute__后触发。


    obj = MyClass()
    print(obj.name)
    print(obj.some_property)
    """
    输出结果：
        访问属性: name
        小明
        访问属性: some_property
        没有这个属性some_property
    """
    
    

# 使用场景:
    动态计算属性：例如计算并缓存属性值。
        class Circle:
            def __init__(self, radius):
                self.radius = radius
                self.area_number = None

            def __getattribute__(self, name):
                if name == 'area':
                    if self.area_number is None:
                        # 动态计算面积
                        self.area_number = 3.14 * self.radius * self.radius
                        return self.area_number
                    return self.area_number
                return super().__getattribute__(name) # 避免递归操作


        c = Circle(5)
        print(c.area)  # 计算并输出面积：78.5
        print(c.area)  # 计算并输出面积：78.5
        
    访问控制：限制对某些敏感属性的访问。
        class SensitiveData:
            def __getattribute__(self, name):
                if name == 'password':
                    raise AttributeError("无法访问属性 'password'")
                return super().__getattribute__(name) # 避免递归操作

        obj = SensitiveData()
        print(obj.password)  # 会抛出 AttributeError

    日志记录和调试：记录每次属性访问。
        class Debugger:
            def __getattribute__(self, name):
                print(f"访问了属性: {name}") # 进行日志记录
                return super().__getattribute__(name) # 避免递归操作

        obj = Debugger()
        obj.some_property  # 输出：访问了属性: some_property
        
    
    方法拦截：动态增加方法的行为。
    class MethodInterceptor:
        def __getattribute__(self, name):
            if name == 'say_hello':
            	print("拦截方法调用: say_hello")
            return super().__getattribute__(name)

        def say_hello(self):
        	return "Hello, World!"

    obj = MethodInterceptor()
    print(obj.say_hello())  # 输出：拦截方法调用: say_hello 和 Hello, World!
```

### `__getattribute__redis缓存案例`

```bash
import redis


class RedisLink:
    __doc__ = "redis链接池"
    _instance = None

    def __new__(cls, *args, **kwargs):
        """
        单例模式
        :param args:
        :param kwargs:
        """
        if not cls._instance:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self, ip="localhost", port=6379, password=None):
        """

        :param ip: redis ip地址
        :param port: redis 端口
        :param password: redis 密码
        """
        self.ip = ip
        self.port = port
        self.password = password
        self._client = None

    def __getattribute__(self, item):
        """
        :param item:
        :return:
        """

        if item == "client": # 触发条件
            if not self._client:
                print(item)
                pool = redis.ConnectionPool(
                    host=self.ip,  # Redis 服务器地址
                    port=self.port,  # Redis 服务器端口
                    db=0,  # 数据库编号
                    password=self.password,  # Redis 密码（如果有）
                    max_connections=10,  # 最大连接数
                    socket_timeout=10,  # 连接超时时间（秒）
                    decode_responses=True  # 是否将 Redis 返回的结果解码为字符串
                )
                # 使用连接池创建 Redis 连接对象
                self._client = redis.Redis(connection_pool=pool)
                return self._client
            return self._client

        return super().__getattribute__(item)


# 创建一个 Redis 连接对象
redis_link = RedisLink(ip="localhost", port=6379, password=None)

# 第一次访问 client，会触发 Redis 客户端的初始化
client = redis_link.client
print(client)  # 输出 Redis 客户端对象

# 再次访问 client，直接返回缓存的 Redis 客户端
client2 = redis_link.client
print(client2)  # 输出相同的 Redis 客户端对象

"""
输出的结果：
client
Redis<ConnectionPool<Connection<host=localhost,port=6379,db=0>>>
Redis<ConnectionPool<Connection<host=localhost,port=6379,db=0>>>
"""
```

### `__setattr__与__delattr__与__setattr__`

```bash
1.__getattr__ # 访问属性，触发
	触发条件：当你访问一个实例的属性，而这个属性 不存在（也就是找不到）时，Python 会自动调用 __getattr__ 方法。# 只针对属性
	class MyClass:
        class_name = "a"

        def __init__(self, name):
            self.name = name  # 实例化属性

            def __getattr__(self, val):
                """
                    当访问的属性（类属性，实例化属性）不存在时，__getattr__ 会被调用。
                    val：接受属性不存在的属性名称
                    :return:
                    """
                return f"{val}无属性！"


        f = MyClass("测试")
        print(f.name)  # 输出：测试
        print(f.class_name)  # 输出：age无属性！
        print(f.age)  # 输出：age无属性！
        print(f.class_age)  # 输出：class_age无属性！
        
        
        
        场景：延迟加载
        class DataFetcher:
            def __getattr__(self, name):
                # 假设从数据库中动态获取数据
                value = f"从数据库获取 {name}"
                setattr(self, name, value)  # 延迟属性初始化,setattr设置,初始化是实例化对象后设置实例化属性
                return value


        f = DataFetcher()
        print(f.user)  # 输出：从数据库获取 user
        
        场景：代理对象
        class Proxy:
            def __init__(self, target):
                self._target = target # 接受了实例化对象

            def __getattr__(self, name):
                # name=greet()
                return getattr(self._target, name) # 使用反射，也就是通过这个实例化对象方法，调用了greet()方法等同于RealObject().greet()


        class RealObject:
            def greet(self):
                return "Hello"


        proxy = Proxy(RealObject())
        print(proxy.greet())  # 输出：Hello
        
```

```python
1.__setattr__ # 在赋值时触发
	# 是 Python 中的一个特殊方法，用于拦截和控制属性赋值操作。如果在初始化没有这个变量，也可以在通过实例化进行设置，注意避免递归。
	
class Person:
    def __init__(self, age):
        self.age = age

    def __setattr__(self, name, value):
        if name == "age":
            if not isinstance(value, int) or value < 0:
                raise ValueError("年龄必须是非负整数")
        super().__setattr__(name, value)  # 避免无限递归，super()调用父类的__setattr__，而不是在当前类的__setattr__。


# 测试
p = Person(30)
print(p.age)  # 输出： 30

p.age = 25  # 正常赋值
p.name = "tom"  # 正常赋值，就算实例化没有个变量也可以进行设置
print(p.age)  # 输出： 25
p.age = -5  # 抛出异常：年龄必须是非负整数



# 关于递归的问题：
def __setattr__(self, name, value):
    self.name = value # 这个操作本质上就是 self.__setattr__('name', value)【语言基本的调用】，根据类的特性有先在本类中找对应的方法，然后再去找集成类的方法，因为本类有__setattr__这个方法就会进行调用，然后就会导致一直自己调用自己类__setattr__方法导致递归，使用：super().__setattr__(name, value)就是为了避免递归，super()就是直接使用父类的方法，不在本类找。

    赋值的语法糖：
    	obj.attr = value
        obj.__setattr__('attr', value) # 语法糖底层实现
    
    通过下面的方法可以验证这个问题
    class MyClass:
        def __setattr__(self, name, value):
            print(f"调用了 __setattr__：{name} = {value}")
            self.name = value # 这个动作就是一直在调用本类的 __setattr__ 方法，导致递归
            # super().__setattr__(name, value)


     obj = MyClass()
     obj.x = 10  # 打印：调用了 __setattr__：x = 10 从第二条开始打印：调用了 __setattr__：name = 10，然后到报错：RecursionError: maximum recursion depth exceeded while calling a Python object

```

```python
1.__delattr__
	作用：__delattr__ 允许你拦截并自定义属性删除行为，就像 __setattr__ 是属性赋值的钩子一样。
class Person:
    def __init__(self):
        self.name = "Tom"
        self.age = 25

    def __delattr__(self, name):
        if name == "name":
            raise AttributeError("不能删除 name 属性")
        # del self.name  # 触发递归操作
        super().__delattr__(name)  # 调用父类避免递归错误，正常删除其他属性


p = Person()
print(p.__dict__)  # {'name': 'Tom', 'age': 25}

del p.age  # 删除 age
print(p.__dict__)  # {'name': 'Tom'}

del p.name  # 抛出异常
# AttributeError: 不能删除 name 属性

在这个属性下可以操作:
    进行权限控制
    记录日志
    限制某些属性不能删除
    实现自定义对象行为（如延迟删除、假删除）
    与数据库或其他后端联动（如 ORM 框架）
```



## `__get__`

## `__set__`

## `__delete__`

## `__objclass__`

## `__slots__`
